<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Babylon - Basic scene</title>
    <style>
    html,
    body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
    }
    
    #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
    }
    </style>
    <script src="http://cdn.babylonjs.com/2-5/babylon.js"></script>
    <script src="hand.js"></script>
    <script src="cannon.js"></script>
    <script src="underscore.js"></script>
    <!-- optional physics engine -->
    <!-- <script src="Oimo.js"></script>  New physics engine -->
</head>

<body>
    <canvas id="renderCanvas"></canvas>
    <script>
    // var camera;

    // Get the canvas element from our HTML above
    var canvas = document.getElementById("renderCanvas");

    // Load the BABYLON 3D engine
    var engine = new BABYLON.Engine(canvas, true);

    var createScene = function() {

        var scene = new BABYLON.Scene(engine);

        // Lights
        var light0 = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(-2, -5, 2), scene);
        var light1 = new BABYLON.PointLight("Omni", new BABYLON.Vector3(2, -5, -2), scene);

        // Need a free camera for collisions
        var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(0, -8, -20), scene);
        camera.attachControl(canvas, true);
        camera.speed = 1.4;
        camera.keysUp.push(87); // "w"
        camera.keysDown.push(83); // "s"
        camera.keysLeft.push(65); // "a"
        camera.keysRight.push(68); // "d"

        camera.inertia = 0;
        camera.angularSensibility = 1000;

        //Ground
        var ground = BABYLON.Mesh.CreatePlane("ground", 20.0, scene);
        ground.material = new BABYLON.StandardMaterial("groundMat", scene);
        ground.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
        ground.material.backFaceCulling = false;
        ground.position = new BABYLON.Vector3(5, -10, -15);
        ground.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0);

        //Simple crate
        var box = new BABYLON.Mesh.CreateBox("crate", 2, scene);
        // box.material = new BABYLON.StandardMaterial("Mat", scene);
        // box.material.diffuseTexture = new BABYLON.Texture("textures/crate.png", scene);
        // box.material.diffuseTexture.hasAlpha = true;
        box.position = new BABYLON.Vector3(5, -9, -10);

        var light0 = new BABYLON.DirectionalLight("Dir0", new BABYLON.Vector3(1, -1, 0), scene);
        light0.diffuse = new BABYLON.Color3(1, 0, 0);
        light0.specular = new BABYLON.Color3(1, 1, 1);
        light0.intensity = 4;

        //Set gravity for the scene (G force like, on Y-axis)
        scene.gravity = new BABYLON.Vector3(0, -0.9, 0);

        // Enable Collisions
        scene.collisionsEnabled = true;

        //Then apply collisions and gravity to the active camera
        camera.checkCollisions = true;
        camera.applyGravity = true;

        //Set the ellipsoid around the camera (e.g. your player's size)
        camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);

        //finally, say which mesh will be collisionable
        ground.checkCollisions = true;
        box.checkCollisions = true;

        // BABYLON.SceneLoader.ImportMesh("house", "wcafe/", "wcafe.babylon", scene, function(newMeshes, particleSystems) {
        //     console.log(newMeshes);
        //     console.log(particleSystems);
        // });

        window.addEventListener("keydown", onKeyUp, false);

        function onKeyUp(event) {
            switch (event.keyCode) {
                case 32:
                    cameraJump();
                    break;
            }
        }

        var cameraJump = function() {
            var cam = scene.cameras[0];

            cam.animations = [];

            var a = new BABYLON.Animation(
                "a",
                "position.y", 20,
                BABYLON.Animation.ANIMATIONTYPE_FLOAT,
                BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

            // Animation keys
            var keys = [];
            keys.push({
                frame: 0,
                value: cam.position.y
            });
            keys.push({
                frame: 10,
                value: cam.position.y + 2
            });
            keys.push({
                frame: 20,
                value: cam.position.y
            });
            a.setKeys(keys);

            var easingFunction = new BABYLON.CircleEase();
            easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);
            a.setEasingFunction(easingFunction);

            cam.animations.push(a);

            scene.beginAnimation(cam, 0, 20, false);
        }


        //We start without being locked.
        var isLocked = false;

        // On click event, request pointer lock
        scene.onPointerDown = function(evt) {

            //true/false check if we're locked, faster than checking pointerlock on each single click.
            if (!isLocked) {
                canvas.requestPointerLock = canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
                if (canvas.requestPointerLock) {
                    canvas.requestPointerLock();
                }
            }

            //continue with shooting requests or whatever :P
            //evt === 0 (left mouse click)
            //evt === 1 (mouse wheel click (not scrolling))
            //evt === 2 (right mouse click)
        };


        // Event listener when the pointerlock is updated (or removed by pressing ESC for example).
        var pointerlockchange = function() {
            var controlEnabled = document.mozPointerLockElement || document.webkitPointerLockElement || document.msPointerLockElement || document.pointerLockElement || null;

            // If the user is already locked
            if (!controlEnabled) {
                //camera.detachControl(canvas);
                isLocked = false;
            } else {
                //camera.attachControl(canvas);
                isLocked = true;
            }
        };

        // Attach events to the document
        document.addEventListener("pointerlockchange", pointerlockchange, false);
        document.addEventListener("mspointerlockchange", pointerlockchange, false);
        document.addEventListener("mozpointerlockchange", pointerlockchange, false);
        document.addEventListener("webkitpointerlockchange", pointerlockchange, false);

        return scene;
    };

    // Now, call the createScene function that you just finished creating
    var scene = createScene();
    console.log(scene);

    expandedLog = (function() {
        var MAX_DEPTH = 3;

        return function(item, depth) {

            depth = depth || 0;

            if (depth > MAX_DEPTH) {
                console.log(item);
                return;
            }

            if (_.isObject(item)) {
                _.each(item, function(value, key) {
                    console.group(key + ' : ' + (typeof value));
                    expandedLog(value, depth + 1);
                    console.groupEnd();
                });
            } else {
                console.log(item);
            }
        }
    })();

    // Register a render loop to repeatedly render the scene
    engine.runRenderLoop(function() {
        scene.render();
        // console.log(camera.position);
    });

    // Watch for browser/canvas resize events
    window.addEventListener("resize", function() {
        engine.resize();
    });
    </script>
</body>

</html>
